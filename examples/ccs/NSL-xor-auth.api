// NSL with xor
// A -> B: aenc(<na,A>,pub(B))
// B -> A: aenc(<na+B,nb>,pub(A))
// A -> B: aenc(nb,pub(B))

// Well-known attack
//  A --> I: aenc(<na,A>,pub(I))
// I(A) --> B: aenc(<na + B + I,A>,pub(B))
// B --> : aenc(<na+I,nb>,pub(A))
// I --> A : aenc(<na+I,nb>,pub(A))
// A --> I: aenc(nb,pub(I))
//I(A) --> B: aenc(nb,pub(B))

#set xor;

symbols aenc/2, adec/2, pub/1, h/1,
        pair/2, fst/1, snd/1, i/0;
private na, nb, a, b;
channels C;
var X,Y,Z;

rewrite adec(aenc(X,pub(Y)),Y) -> X;
rewrite fst(pair(X,Y)) -> X;
rewrite snd(pair(X,Y)) -> Y;


Tinit = out(C,pub(a)).out(C,pub(b)).0;

RoleAIfst = out(C,aenc(pair(na,pub(a)),pub(i))).0;

RoleAIsnd =
  in(C,X).
  [plus(fst(adec(X,a)),pub(i)) = na].
  out(C,aenc(snd(adec(X,a)),pub(i))).0;

RoleBAfst =
  in(C,Y).[snd(adec(Y,b)) = pub(a)].
  out(C,aenc(pair(plus(fst(adec(Y,b)),pub(b)),nb),snd(adec(Y,b)))).0;

RoleBAsnd = in(C,Z).[adec(Z,b)=nb].0;

// Test only the relevant interleaving

P = Tinit :: RoleAIfst :: RoleBAfst :: RoleAIsnd :: RoleBAsnd:: out(C,zero);
Q = Tinit :: RoleAIfst :: RoleBAfst :: RoleAIsnd :: RoleBAsnd;

not equivalentct? P and Q;
