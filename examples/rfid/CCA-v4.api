// RFID protocol OTYT 06
// cf. Survey Attacks on RFID protocols. T. Deursen and S. Radomirovic
// The protocol is flawed. To help AKISS, we assume that an honest session
// has been eavesdropped.

#set xor;

// Signature xor and h

symbols enc/2, dec/2;
private KM,DATA,IMP,EXP,KPART;
channels c;
var x,xkey,xkek,xkek1,xkek2,xtype,xtype1,xtype2,xtype3,xtypet,xtypef,xkpNew1,xkpNew2,xkpNew3,xkpOld2,xkpOld3,X,Y,Xen,Xd,Yd,Xi,Yi,Xe,Ye,X2,X3,Xt,Yt,Zt,Xf,Yf,Zf;

rewrite dec(enc(X, Y), Y) -> X;

// We model RFID tags that authenticate with a reader
// in the following way:
// Reader and Tag know the key kX and its value will be updated an the end
// of each session

//   reader sends a nonce r1
//   tag sends h(kX + r1)
//   reader sends kX + k1 (k1 fresh key)
//   both update their key kX with k1.

// The protocol does not ensure untraceability: after eavesdropping one honest
// session between the reader and the tag A, the attacker knows
// w0 -> r1; w1 -> h(kA1 + r1); w2 -> kA1 + k1
// Then, a fake reader can initiate a session with
// the  nonce r1 + kA1 + k1 obtained by computing w0 + w2
// and will be able to tell if the two sessions are against
// the same tag or not. Indeed, the previously observed tag
// will respond with h(r1 + kA1 + k1 + k1) = h(r1 + kA1) and this is exactly w1.

// Tinit models the fact that the attacker is  eavesdropping an honest session.
// TtagB2 models the role of a tag B.
// TtagA2 models the following session executed by the tag A.
// Note also that we use new kA1 (i.e. k1) instead of kA1 to model the fact that
// the key has been updated after the first session.


Encipher = in(c,x).in(c,Xen).out(c,enc(x,dec(Xen,plus(KM,DATA)))).0;
Decipher = in(c,Xd).in(c,Yd).out(c,dec(Xd,dec(Yd,plus(KM,DATA)))).0;
KeyImport = in(c,Xi).in(c,xtype).in(c,Yi).out(c,enc(plus(dec(Yi,plus(KM,IMP)),xtype),plus(KM,xtype))).0;
KeyExport = in(c,Xe).in(c,xtype).in(c,Ye).out(c,enc(dec(Xe,plus(KM,xtype)),plus(dec(Ye,plus(KM,EXP)),xtype))).0;
KeyPartImport1 = in(c,xkpNew1).in(c,xtype1).out(c,enc(xkpNew1,plus(plus(KM,xtype1),KPART))).0;
KeyPartImport2 = in(c,xkpNew2).in(c,xtype2).in(c,X2).out(c,enc(plus(xkpNew2,dec(X2,plus(plus(KM,xtype2),KPART))),plus(plus(KM,xtype2),KPART))).0;
KeyPartImport3 = in(c,xkpNew3).in(c,xtype3).in(c,X3).out(c,enc(plus(xkpNew3,dec(X3,plus(plus(KM,xtype3),KPART))),plus(KM,xtype3))).0;
KeyTranslate = in(c,xtypet).in(c,Yt).in(c,Zt).out(c,enc(dec(KM,plus(dec(Yt,plus(KM,IMP)),xtypet)),plus(dec(Zt,plus(KM,EXP)),xtypet))).0;
KeyTranslateF = in(c,Xf).in(c,xtypef).in(c,Yf).in(c,Zf).out(c,enc(dec(Yf,plus(dec(Yf,plus(KM,IMP)),xtypef)),plus(dec(Zf,plus(KM,EXP)),xtypef))).0;


r1 =  KeyTranslate;
r2 =  KeyTranslateF;

equivalentct? r1 and r2;

// AKISS concludes within 30s, returning two tests that correspond exactly
// to the attack mentioned above. This is actually the same test that can be
// done in two different symbolic worlds (before or after the last input action)
