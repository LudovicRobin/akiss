// Simplified version - without pair - of RFID protocol KCL 07
// cf. Survey Attacks on RFID protocols. T. Deursen and S. Radomirovic
// The protocol is flawed. 
// We consider two sessions of the tag. This is almost the real protocol (without pairs).

#set xor;

// Signature xor and h

symbols plus/2, zero/0, h/2;
private idA, idB, r2, r4, kA, kB, ok;
channels C;
var X, Y, Z;

rewrite plus(zero,X) -> X;
rewrite plus(X,X) -> zero;
rewrite plus(X,plus(X,Y)) -> Y;

// We model RFID tags that authenticate with a reader
// in the following way:
//   reader sends a nonce r1
//   tag A sends <idA+r2, h(r1,kA)+r2>

// The protocol does not ensure untraceability: a fake
// reader can initiate two sessions with the same nonce
// and will be able to tell if the two sessions are against
// the same tag or not. Indeed, by xoring the two components
// of the pair one gets idX+h(r1).

// This is almost the real protocol. We do not model the pairing 
// and projections operators but we split each output into two outputs.
// We also add the rewriting rule to ensure coherence

TtagA1 = in(C,Y).out(C,plus(idA,r2)). out(C,plus(h(Y,kA),r2)).0;
TtagA2 = in(C,X).out(C,plus(idA,r4)). out(C,plus(h(X,kA),r4)).0;
TtagB2 = in(C,X).out(C,plus(idB,r4)). out(C,plus(h(X,kB),r4)).0;

r1 = TtagA1 :: TtagA2;
r2 = TtagA1 :: TtagB2;

equivalentct? r1 and r2;


// 22/02/2013: AKISS finds the attack within 18 min - noko (cf. rfid-2b.log rfid-2b.dot rfid-2b.dot.svg)

// 25/11/2013: AKISS concludes within 43 min
// The following tests work on r1 but not on r2:
// check_identity([in(C,!n!25986),[out(C),[out(C),[in(C,!n!25986),[out(C),[out(C),empty]]]]]],plus(plus(plus(plus(plus(w0,w1),w2),w3),X2473),X2473),zero)
// check_identity([in(C,!n!25989),[out(C),[out(C),[in(C,!n!25989),[out(C),[out(C),empty]]]]]],plus(plus(plus(w0,w1),w2),w3),zero)
// check_identity([in(C,!n!25992),[out(C),[out(C),[in(C,!n!25992),[out(C),[out(C),empty]]]]]],plus(plus(plus(plus(plus(w0,w1),w2),w3),X4275),X4275),zero)
// check_identity([in(C,!n!25995),[out(C),[out(C),[in(C,!n!25995),[out(C),[out(C),empty]]]]]],plus(plus(plus(plus(plus(w0,w1),w2),w3),X4672),X4672),zero)
// check_identity([in(C,!n!25998),[out(C),[out(C),[in(C,!n!25998),[out(C),[out(C),empty]]]]]],plus(plus(plus(w0,w1),w2),w3),zero)
// check_identity([in(C,!n!26019),[out(C),[out(C),[in(C,!n!26019),[out(C),[out(C),empty]]]]]],plus(plus(plus(plus(plus(plus(plus(w0,w1),w2),w3),X25752),X25750),X25750),X25752),zero)
// check_identity([in(C,!n!26022),[out(C),[out(C),[in(C,!n!26022),[out(C),[out(C),empty]]]]]],plus(plus(plus(plus(plus(plus(plus(w0,w1),w2),w3),X25760),X25762),X25760),X25762),zero)

check_identity([in(C,!n!26025),[out(C),[out(C),[in(C,!n!26025),[out(C),[out(C),empty]]]]]],plus(plus(plus(plus(plus(plus(plus(w0,w1),w2),w3),X25775),X25772),X25772),X25775),zero)

check_identity([in(C,!n!26028),[out(C),[out(C),[in(C,!n!26028),[out(C),[out(C),empty]]]]]],plus(plus(plus(plus(plus(plus(plus(w0,w1),w2),w3),X25782),X25785),X25782),X25785),zero)

check_identity([in(C,!n!26031),[out(C),[out(C),[in(C,!n!26031),[out(C),[out(C),empty]]]]]],plus(plus(plus(plus(plus(w0,w1),w2),w3),X25792),X25792),zero)

check_identity([in(C,!n!26034),[out(C),[out(C),[in(C,!n!26034),[out(C),[out(C),empty]]]]]],plus(plus(plus(plus(plus(w0,w1),w2),w3),X25798),X25798),zero)
