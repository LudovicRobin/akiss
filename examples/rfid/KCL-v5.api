// RFID protocol KCL07

#set xor;

symbols plus/2, zero/0, h/2, pair/2, fst/1, snd/1;
private idA, idB, r2, r4, kA, kB, r1;
channels C;
var X, Y, Z;

rewrite plus(zero,X) -> X;
rewrite plus(X,X) -> zero;
rewrite plus(X,plus(X,Y)) -> Y;
rewrite fst(pair(X,Y)) -> X;
rewrite snd(pair(X,Y)) -> Y;

// We model RFID tags that authenticate with a reader
// in the following way:
//   reader sends a nonce r1
//   tag A sends <idA+r2, h(r1,kA)+r2>

// The protocol does not ensure untraceability: a fake
// reader can initiate a session with the nonce used in the previous honest session.
// Then, an attacker will be able to tell if the two sessions are against
// the same tag or not. Indeed, by xoring the two components
// of the pair one gets idX+h(r1).


Tinit = out(C,r1).out(C,pair(plus(idA,r2),plus(h(r1,kA),r2))).0;
TtagA2 = in(C,X).out(C,pair(plus(idA,r4),plus(h(X,kA),r4))).0;
TtagB2 = in(C,X).out(C,pair(plus(idB,r4),plus(h(X,kB),r4))).0;

r1 = Tinit :: TtagA2;
r2 = Tinit :: TtagB2;

inequivalentct? r1 and r2;


// 25/02/2013: AKISS finds the attack within  20 min - sume (cf. rfid-3b.log rfid-3b.dot rfid-3b.dot.svg)
// Among the tests we obtain:
// check_identity([out(C),[out(C),[in(C,w0),[out(C),empty]]]],plus(fst(w1),fst(w2)),plus(snd(w1),snd(w2)))
// but also:
// check_identity([out(C),[out(C),[in(C,w0),[out(C),empty]]]],w1,pair(fst(w1),plus(plus(fst(w1),fst(w2)),snd(w2))))

// TODO: I add the rule for coherence but this example has been been tested without this line 

