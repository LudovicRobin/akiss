
// 6/12/2013: le but de cet exemple. 
// Je suis partie de KCL avec paire en cherchant a le simplifier pour essayer de comprendre 
// pourquoi il ne termine pas




#set xor;


 symbols plus/2, zero/0, pair/2, h/2, fst/1, snd/1;
// symbols plus/2, zero/0; 

private idA, idB, r2, r4, kA, kB;
channels C;
var X, Y, Z;

rewrite plus(zero,X) -> X;
rewrite plus(X,X) -> zero;
rewrite plus(X,plus(X,Y)) -> Y;

 rewrite fst(pair(X,Y)) -> X;
 rewrite snd(pair(X,Y)) -> Y;

// version avec paire

//Tinit = in(C,Y).out(C,pair(plus(idA,r2),plus(h(Y,kA),r2))).0;
//TtagA2 = in(C,X).out(C,pair(plus(idA,r4),plus(h(X,kA),r4))).0;
//TtagB2 = in(C,X).out(C,pair(plus(idB,r4),plus(h(X,kB),r4))).0;

// version sans paire

 Tinit = in(C,Y).out(C,plus(idA,r2)).out(C,plus(h(Y,kA),r2)).0;
 TtagA2 = in(C,X).out(C,plus(idA,r4)).out(C,plus(h(X,kA),r4)).0;
 TtagB2 = in(C,X).out(C,plus(idB,r4)).out(C,plus(h(X,kB),r4)).0;

r1 = Tinit :: TtagA2;
r2 = Tinit :: TtagB2;

equivalentct? r1 and r2;


// Version sans paire mais avec paire declare: termine sans conseq ()

// Version avec paire et conseq (sauf +) active: termine ()

// Version avec paire et seulement axiom de conseq active: termine (46 s)

// ajout de r1 et du symbole h (54s)

// ajout d'un input inutile: 1m 31s

// ajout de la variable dans l'output 1m54s.

// Tinit est maintenant le vrai protocole et pas seulement une frame. Termine en 2m20s
// (Meme exemple mais sans paire - termine aussi en 2m17s)


